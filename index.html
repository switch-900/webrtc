<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Relay Companion</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;margin:0;padding:14px;background:#0d0d0d;color:#ccc}
    h2{color:#f7931a;margin:0 0 6px;font-size:18px}
    .sub{opacity:.65;font-size:12px;margin:0 0 12px}
    .pill{display:inline-block;padding:2px 10px;border-radius:99px;font-size:11px;font-weight:800}
    .ok{background:#1a4d2e;color:#6fcf97}.bad{background:#4d1a1a;color:#f28b82}.wait{background:#4d3e1a;color:#f5c842}
    pre{background:#0b1020;color:#d6e1ff;padding:12px;border-radius:10px;overflow:auto;max-height:55vh}
    .hex{font-family:monospace;font-size:11px;color:#666;word-break:break-all;margin:6px 0 0}
    .back{background:#f7931a;color:#000;font-weight:800;cursor:pointer;border:none;padding:8px 16px;border-radius:8px;font-size:13px;margin-top:10px}
    .back:hover{background:#ffaa33}
  </style>
</head>
<body>
  <h2>‚ö° Relay Companion</h2>
  <p class="sub">Keep this tab open. Proxies fetch requests for the inscription over WebRTC.</p>
  <div style="display:flex;align-items:center;gap:10px">
    <span id="status" class="pill bad">offline</span>
    <button class="back" id="backBtn">‚Üê Back to Inscription</button>
  </div>
  <p class="hex" id="lobbyId"></p>
  <pre id="log">‚Ä¶</pre>

<script>
(() => {
  const logEl = document.getElementById("log");
  const statusEl = document.getElementById("status");
  const lobbyEl = document.getElementById("lobbyId");

  const log = (...a) => {
    const m = a.map(x => typeof x === "string" ? x : JSON.stringify(x, null, 2)).join(" ");
    logEl.textContent = m + "\n\n" + logEl.textContent;
  };
  const setStatus = (t) => {
    statusEl.textContent = t;
    statusEl.className = "pill " + (t === "connected" || t === "relaying" ? "ok" : t.includes("‚Ä¶") ? "wait" : "bad");
  };

  /* ‚îÄ‚îÄ Lobby = inscription hex from URL hash ‚îÄ‚îÄ */
  const LOBBY = decodeURIComponent((location.hash || "").replace(/^#/, ""));
  if (!LOBBY) {
    setStatus("no lobby");
    log("‚ùå No inscription hex in URL hash. Open this page from the inscription.");
    return;
  }

  lobbyEl.textContent = "lobby: " + LOBBY.slice(0, 12) + "‚Ä¶" + LOBBY.slice(-6);

  let pc = null, dc = null, fetchCount = 0;
  let openerRef = null; // reference to inscription window (via event.source)

  /* ‚îÄ‚îÄ Listen for postMessage from inscription ‚îÄ‚îÄ */
  window.addEventListener("message", async (ev) => {
    let msg;
    try { msg = typeof ev.data === "string" ? JSON.parse(ev.data) : ev.data; } catch { return; }
    if (!msg || msg.lobby !== LOBBY) return;

    // Save reference to inscription window from event.source
    if (ev.source) openerRef = ev.source;

    /* Ping ‚Üí respond with relay-ready */
    if (msg.type === "ping") {
      if (openerRef) {
        openerRef.postMessage(JSON.stringify({ lobby: LOBBY, type: "relay-ready" }), "*");
      }
      return;
    }

    /* Offer ‚Üí create answer */
    if (msg.type === "offer" && msg.sdp) {
      log("‚¨ÖÔ∏è Offer received. Creating answer‚Ä¶");

      pc = new RTCPeerConnection({
        iceServers: [
          { urls: "stun:stun.l.google.com:19302" },
          { urls: "stun:stun1.l.google.com:19302" },
          { urls: "stun:stun2.l.google.com:19302" },
        ]
      });

      pc.onicecandidate = (e) => {
        if (e.candidate && openerRef) {
          openerRef.postMessage(JSON.stringify({
            lobby: LOBBY, type: "ice", candidate: e.candidate
          }), "*");
        }
      };

      pc.onconnectionstatechange = () => {
        log("üîå", pc.connectionState);
        if (pc.connectionState === "connected") setStatus("connected");
        if (pc.connectionState === "disconnected" || pc.connectionState === "failed") setStatus(pc.connectionState);
      };

      pc.ondatachannel = (event) => {
        dc = event.channel;
        log("‚úÖ DataChannel:", dc.label);

        dc.onopen = () => { log("‚úÖ Relay active ‚Äî proxying fetches!"); setStatus("relaying"); };
        dc.onclose = () => { log("‚ö†Ô∏è Channel closed."); setStatus("offline"); };

        dc.onmessage = async (ev) => {
          let m;
          try { m = JSON.parse(ev.data); } catch { return; }
          if (m.type !== "fetch" || !m.id || !m.url) return;

          fetchCount++;
          log("‚û°Ô∏è [" + fetchCount + "] " + m.url);

          try {
            const resp = await fetch(m.url, {
              method: m.method || "GET",
              headers: m.headers || { accept: "application/json" },
            });
            const body = await resp.text();
            dc.send(JSON.stringify({
              type: "fetch_result", id: m.id, url: m.url,
              ok: resp.ok, status: resp.status, statusText: resp.statusText,
              headers: Object.fromEntries(resp.headers.entries()), body
            }));
            log("‚úÖ [" + fetchCount + "] " + resp.status + " (" + body.length + "b)");
          } catch (e) {
            dc.send(JSON.stringify({
              type: "fetch_result", id: m.id, url: m.url,
              ok: false, status: 0, statusText: "FETCH_ERROR",
              headers: {}, body: String(e?.message || e)
            }));
            log("‚ùå [" + fetchCount + "] " + String(e));
          }
        };
      };

      await pc.setRemoteDescription({ type: "offer", sdp: msg.sdp });
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);

      openerRef.postMessage(JSON.stringify({
        lobby: LOBBY, type: "answer", sdp: answer.sdp
      }), "*");
      log("‚û°Ô∏è Answer sent. Connecting P2P‚Ä¶");
      setStatus("connecting‚Ä¶");
    }

    /* ICE candidates */
    if (msg.type === "ice" && msg.candidate && pc) {
      try { await pc.addIceCandidate(msg.candidate); } catch (e) { log("‚ö†Ô∏è ICE:", String(e)); }
    }
  });

  /* ‚îÄ‚îÄ Back button ‚Üí focus opener tab ‚îÄ‚îÄ */
  document.getElementById("backBtn").onclick = () => {
    if (window.opener) {
      window.opener.focus();
    } else {
      history.back();
    }
  };

  /* ‚îÄ‚îÄ Signal ready (also via window.opener if available) ‚îÄ‚îÄ */
  setStatus("waiting‚Ä¶");
  log("‚è≥ Lobby: " + LOBBY);
  log("Waiting for inscription to ping‚Ä¶");

  // Signal ready to parent (iframe) or opener (popup)
  const parentRef = (window.parent !== window) ? window.parent : window.opener;
  if (parentRef) {
    try {
      parentRef.postMessage(JSON.stringify({ lobby: LOBBY, type: "relay-ready" }), "*");
      log("‚úÖ Sent ready to parent.");
      setStatus("waiting for offer‚Ä¶");
    } catch {}
  }
})();
</script>
</body>
</html>
